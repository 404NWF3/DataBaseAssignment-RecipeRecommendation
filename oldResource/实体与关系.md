# 菜谱推荐网站数据库实体关系设计方案

完整实体关系方案分为 **核心内容域**、**用户域**、**交互域** 和 **元数据域** 四大模块。

## 一、 核心内容域 (Content Domain)

### 1. `Recipes` (菜谱主表)
存储菜谱的基础信息。
* **主键:** `recipe_id`
* **基础属性:**
    * `title`: 菜谱标题
    * `description`: 简介/背后的故事
    * `cover_image_url`: 成品封面图（可选）
    * `video_url`: 教学视频链接 (可选)
    * `status`: 状态 (草稿/发布/封禁)
* **元数据属性 (用于筛选):**
    * `difficulty`: 难度 (Easy, Medium, Hard)
    * `cooking_time`: 烹饪时长 (分钟)
    * `preparation_time`: 备菜时长 (分钟)
    * `servings`: 份量 (如：2人份)
* **统计属性 (反范式化设计，用于快速排序):**
    * `view_count`: 浏览量
    * `like_count`: 点赞/收藏数
    * `rating_avg`: 平均评分 (如 4.8)

### 2. `Ingredients` (食材库 - 标准化字典)
**核心设计点：** 不要直接在菜谱里存“西红柿”，而要建立一个独立的 ID。
* **主键:** `ingredient_id`
* **属性:**
    * `name`: 标准名称 (如 "鸡蛋")
    * `alias`: 别名/搜索关键词 (如 "鸡子,若鸡,egg"，用逗号分隔，提升搜索命中率)
    * `category_id`: 食材分类 (如：肉禽类、蔬菜类)
    * `image_url`: 食材缩略图
    * **关系:** 与 `Recipes` 是多对多关系。

### 3. `Recipe_Ingredients` (菜谱-食材关联表)
这是实现“基于食材推荐”的关键。
* **主键:** `id`
* **外键:** `recipe_id`, `ingredient_id`
* **属性:**
    * `quantity`: 数量数值 (如 200, 0.5)
    * `unit`: 单位 (如 "克", "汤匙", "个")
    * `remark`: 预处理备注 (如 "切丁", "去皮")
    * `is_main`: 是否为主料 (Boolean，用于计算权重，主料匹配度更重要)

### 4. `Steps` (烹饪步骤)
* **主键:** `step_id`
* **外键:** `recipe_id`
* **属性:**
    * `step_number`: 顺序号 (1, 2, 3...)
    * `description`: 步骤文字详情
    * `image_url`: 步骤图
    * `timer_seconds`: 步骤计时器 (如：炖煮30分钟，前端可显示倒计时)

### 5. `Nutrition` (营养成分表 - 可选但加分)
* **外键:** `recipe_id` (一对一关系)
* **属性:** `calories` (卡路里), `protein`, `fat`, `carbohydrates`, `sodium` (钠 - 用于高血压人群筛选).

---

## 二、 用户域 (User Domain)
为了做个性化推荐，必须给用户“画像”。

### 1. `Users` (用户基本表)
* **主键:** `user_id`
* **属性:** `username`, `email`, `password_hash`, `avatar_url`, `bio`.
* **等级属性:** `level` (如：厨房小白/米其林大厨), `points` (积分).

### 2. `User_Preferences` (用户偏好 - 推荐系统的强规则)
记录用户的饮食禁忌和口味。
* **外键:** `user_id`
* **属性:**
    * `dietary_type`: 饮食法 (JSON存储，如 `["vegan", "keto", "halal"]`)
    * `allergies`: 过敏源 (关联到 Ingredient ID，推荐时必须**强过滤**剔除)
    * `disliked_ingredients`: 不爱吃的食材 (推荐时降权)
    * `spicy_tolerance`: 辣度接受等级 (0-5)

---

### 三、 交互与推荐域 (Interaction & RecSys Domain)
这部分数据价值最高，用于计算协同过滤（Collaborative Filtering）。

#### 1. `Collections` (收藏夹/菜单)
用户不仅会收藏，还会建立“年夜饭菜单”、“减脂餐单”。
* **主键:** `collection_id`
* **外键:** `user_id`
* **属性:** `name` (如 "我的早餐"), `is_public` (是否公开分享).

#### 2. `Collection_Items` (收藏夹内容)
* **外键:** `collection_id`, `recipe_id`
* **属性:** `created_at` (收藏时间).

#### 3. `Reviews` (评价与晒图)
显式反馈 (Explicit Feedback)。
* **主键:** `review_id`
* **外键:** `user_id`, `recipe_id`
* **属性:**
    * `rating`: 评分 (1-5星)
    * `content`: 文字评价
    * `image_url`: 用户上传的成品图 (这是社区活跃度的关键)
    * `tags`: 用户给的评价标签 (如 "太咸了", "简单易学")

#### 4. `User_Behavior_Logs` (行为日志 - 隐式反馈)
用户如果不评论，你怎么知道他喜不喜欢？看行为。
* **主键:** `log_id` (通常使用时序数据库或NoSQL，但在关系型数据库中也可以存)
* **外键:** `user_id`, `recipe_id` (如果有)
* **属性:**
    * `action_type`: 行为类型 (枚举: `view`, `share`, `print`, `add_to_cart`, `search`)
    * `duration`: 停留时长 (秒) —— *停留越久，感兴趣概率越大*
    * `search_keyword`: 如果是搜索行为，记录搜了什么
    * `timestamp`: 发生时间

#### 5. `Follows` (社交关系)
* **外键:** `follower_id`, `followed_id`
* **作用:** 基于社交关系的推荐（即“你关注的大厨发布了新菜”）。

---

### 四、 元数据与分类域 (Metadata Domain)
用于多维度的筛选和打标。

#### 1. `Tags` (标签库)
* **主键:** `tag_id`
* **属性:** `name` (如 "川菜", "快手", "适合夏天", "痛风友好")
* **关系:** 与 Recipes 是多对多。

#### 2. `Categories` (分类树)
* **主键:** `category_id`
* **属性:** `name`, `parent_id` (实现层级，如 中餐 -> 川菜 -> 凉菜).

---

### 设计总结：如何支撑推荐逻辑？

1.  **基于内容的推荐 (Content-Based):**
    * 查询 `Recipe_Ingredients` 和 `Tags`。
    * *场景:* 用户正在看“宫保鸡丁”，系统查询同含有“鸡肉”且标签为“川菜”的其他菜谱。

2.  **协同过滤推荐 (Collaborative Filtering):**
    * 利用 `Reviews` 和 `Collections`。
    * *场景:* 发现用户A和用户B都收藏了同样的5个菜谱，那么把用户A收藏的第6个菜谱推荐给用户B。

3.  **排除法推荐 (Negative Filtering):**
    * 利用 `User_Preferences` 中的 `allergies`。
    * *场景:* 无论算法算出什么，只要 `Recipe_Ingredients` 包含用户过敏的 `ingredient_id`，一律剔除。

这个设计方案是否符合您的预期？如果有特定的技术栈（如您想用 MySQL 还是 MongoDB），我可以进一步细化字段的数据类型。